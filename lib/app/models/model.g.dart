// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Checkin.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Checkin TABLE
class TableCheckin extends SqfEntityTableBase {
  TableCheckin() {
    // declare properties of EntityTable
    tableName = 'checkin';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('grupoEmpresarialId', DbType.integer),
      SqfEntityFieldBase('fornecedorDesc', DbType.text),
      SqfEntityFieldBase('grupoEmpresarialDesc', DbType.text),
      SqfEntityFieldBase('lojaId', DbType.integer),
      SqfEntityFieldBase('fornecedorId', DbType.integer),
      SqfEntityFieldBase('motoristaId', DbType.integer),
      SqfEntityFieldBase('dtChegada', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('dtPrevisaoEntrada', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('dtEntrada', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('dtInicio', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('dtTermino', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('dtCancelado', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('status', DbType.text),
      SqfEntityFieldBase('statusDesc', DbType.text),
      SqfEntityFieldBase('docaDesc', DbType.text),
      SqfEntityFieldBase('docaId', DbType.integer),
      SqfEntityFieldBase('veiculoId', DbType.integer),
      SqfEntityFieldBase('veiculoPlaca', DbType.integer),
      SqfEntityFieldBase('veiculoTipoId', DbType.integer),
      SqfEntityFieldBase('prioridade', DbType.integer),
      SqfEntityFieldBase('lojaDesc', DbType.text),
      SqfEntityFieldBase('motoristaNome', DbType.text),
      SqfEntityFieldBase('veiculoTipoDesc', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCheckin();
  }
}

// Nf_compra TABLE
class TableNf_compra extends SqfEntityTableBase {
  TableNf_compra() {
    // declare properties of EntityTable
    tableName = 'nf_compra';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('chaveNf', DbType.text),
      SqfEntityFieldBase('fornecedorDesc', DbType.text),
      SqfEntityFieldBase('valorTotal', DbType.real),
      SqfEntityFieldBase('statusDesc', DbType.text),
      SqfEntityFieldRelationshipBase(
          TableCheckin.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'id_checkin'),
      SqfEntityFieldBase('numNf', DbType.text),
      SqfEntityFieldBase('serieNf', DbType.text),
      SqfEntityFieldBase('dtCadastro', DbType.text),
      SqfEntityFieldBase('status', DbType.text),
      SqfEntityFieldBase('dtEntrada', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('erpId', DbType.integer),
      SqfEntityFieldBase('fornecedorId', DbType.integer),
      SqfEntityFieldBase('lojaId', DbType.integer),
      SqfEntityFieldBase('excluida', DbType.bool),
      SqfEntityFieldBase('dtEmissao', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableNf_compra();
  }
}

// Usuario TABLE
class TableUsuario extends SqfEntityTableBase {
  TableUsuario() {
    // declare properties of EntityTable
    tableName = 'usuario';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableVeiculo.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'id_veiculo'),
      SqfEntityFieldRelationshipBase(TableRede.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'id_rede'),
      SqfEntityFieldBase('cpf', DbType.text),
      SqfEntityFieldBase('nome', DbType.text),
      SqfEntityFieldBase('email', DbType.text),
      SqfEntityFieldBase('telefone', DbType.text),
      SqfEntityFieldBase('foto', DbType.text),
      SqfEntityFieldBase('status', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUsuario();
  }
}

// Rede TABLE
class TableRede extends SqfEntityTableBase {
  TableRede() {
    // declare properties of EntityTable
    tableName = 'redes';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('descricao', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableRede();
  }
}

// Veiculo TABLE
class TableVeiculo extends SqfEntityTableBase {
  TableVeiculo() {
    // declare properties of EntityTable
    tableName = 'veiculos';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('tipoVeiculo', DbType.text),
      SqfEntityFieldBase('placa', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableVeiculo();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class MyDbModel extends SqfEntityModelProvider {
  MyDbModel() {
    databaseName = myDbModel.databaseName;
    password = myDbModel.password;
    dbVersion = myDbModel.dbVersion;
    preSaveAction = myDbModel.preSaveAction;
    logFunction = myDbModel.logFunction;
    databaseTables = [
      TableCheckin.getInstance,
      TableNf_compra.getInstance,
      TableUsuario.getInstance,
      TableRede.getInstance,
      TableVeiculo.getInstance,
    ];

    bundledDatabasePath = myDbModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = myDbModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Checkin
class Checkin extends TableBase {
  Checkin(
      {this.id,
      this.grupoEmpresarialId,
      this.fornecedorDesc,
      this.grupoEmpresarialDesc,
      this.lojaId,
      this.fornecedorId,
      this.motoristaId,
      this.dtChegada,
      this.dtPrevisaoEntrada,
      this.dtEntrada,
      this.dtInicio,
      this.dtTermino,
      this.dtCancelado,
      this.status,
      this.statusDesc,
      this.docaDesc,
      this.docaId,
      this.veiculoId,
      this.veiculoPlaca,
      this.veiculoTipoId,
      this.prioridade,
      this.lojaDesc,
      this.motoristaNome,
      this.veiculoTipoDesc}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Checkin.withFields(
      this.id,
      this.grupoEmpresarialId,
      this.fornecedorDesc,
      this.grupoEmpresarialDesc,
      this.lojaId,
      this.fornecedorId,
      this.motoristaId,
      this.dtChegada,
      this.dtPrevisaoEntrada,
      this.dtEntrada,
      this.dtInicio,
      this.dtTermino,
      this.dtCancelado,
      this.status,
      this.statusDesc,
      this.docaDesc,
      this.docaId,
      this.veiculoId,
      this.veiculoPlaca,
      this.veiculoTipoId,
      this.prioridade,
      this.lojaDesc,
      this.motoristaNome,
      this.veiculoTipoDesc) {
    _setDefaultValues();
  }
  Checkin.withId(
      this.id,
      this.grupoEmpresarialId,
      this.fornecedorDesc,
      this.grupoEmpresarialDesc,
      this.lojaId,
      this.fornecedorId,
      this.motoristaId,
      this.dtChegada,
      this.dtPrevisaoEntrada,
      this.dtEntrada,
      this.dtInicio,
      this.dtTermino,
      this.dtCancelado,
      this.status,
      this.statusDesc,
      this.docaDesc,
      this.docaId,
      this.veiculoId,
      this.veiculoPlaca,
      this.veiculoTipoId,
      this.prioridade,
      this.lojaDesc,
      this.motoristaNome,
      this.veiculoTipoDesc) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Checkin.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['grupoEmpresarialId'] != null) {
      grupoEmpresarialId = int.tryParse(o['grupoEmpresarialId'].toString());
    }
    if (o['fornecedorDesc'] != null) {
      fornecedorDesc = o['fornecedorDesc'].toString();
    }
    if (o['grupoEmpresarialDesc'] != null) {
      grupoEmpresarialDesc = o['grupoEmpresarialDesc'].toString();
    }
    if (o['lojaId'] != null) {
      lojaId = int.tryParse(o['lojaId'].toString());
    }
    if (o['fornecedorId'] != null) {
      fornecedorId = int.tryParse(o['fornecedorId'].toString());
    }
    if (o['motoristaId'] != null) {
      motoristaId = int.tryParse(o['motoristaId'].toString());
    }
    if (o['dtChegada'] != null) {
      dtChegada = int.tryParse(o['dtChegada'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dtChegada'].toString())!)
          : DateTime.tryParse(o['dtChegada'].toString());
    }
    if (o['dtPrevisaoEntrada'] != null) {
      dtPrevisaoEntrada =
          int.tryParse(o['dtPrevisaoEntrada'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['dtPrevisaoEntrada'].toString())!)
              : DateTime.tryParse(o['dtPrevisaoEntrada'].toString());
    }
    if (o['dtEntrada'] != null) {
      dtEntrada = int.tryParse(o['dtEntrada'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dtEntrada'].toString())!)
          : DateTime.tryParse(o['dtEntrada'].toString());
    }
    if (o['dtInicio'] != null) {
      dtInicio = int.tryParse(o['dtInicio'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dtInicio'].toString())!)
          : DateTime.tryParse(o['dtInicio'].toString());
    }
    if (o['dtTermino'] != null) {
      dtTermino = int.tryParse(o['dtTermino'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dtTermino'].toString())!)
          : DateTime.tryParse(o['dtTermino'].toString());
    }
    if (o['dtCancelado'] != null) {
      dtCancelado = int.tryParse(o['dtCancelado'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dtCancelado'].toString())!)
          : DateTime.tryParse(o['dtCancelado'].toString());
    }
    if (o['status'] != null) {
      status = o['status'].toString();
    }
    if (o['statusDesc'] != null) {
      statusDesc = o['statusDesc'].toString();
    }
    if (o['docaDesc'] != null) {
      docaDesc = o['docaDesc'].toString();
    }
    if (o['docaId'] != null) {
      docaId = int.tryParse(o['docaId'].toString());
    }
    if (o['veiculoId'] != null) {
      veiculoId = int.tryParse(o['veiculoId'].toString());
    }
    if (o['veiculoPlaca'] != null) {
      veiculoPlaca = int.tryParse(o['veiculoPlaca'].toString());
    }
    if (o['veiculoTipoId'] != null) {
      veiculoTipoId = int.tryParse(o['veiculoTipoId'].toString());
    }
    if (o['prioridade'] != null) {
      prioridade = int.tryParse(o['prioridade'].toString());
    }
    if (o['lojaDesc'] != null) {
      lojaDesc = o['lojaDesc'].toString();
    }
    if (o['motoristaNome'] != null) {
      motoristaNome = o['motoristaNome'].toString();
    }
    if (o['veiculoTipoDesc'] != null) {
      veiculoTipoDesc = o['veiculoTipoDesc'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Checkin)
  int? id;
  int? grupoEmpresarialId;
  String? fornecedorDesc;
  String? grupoEmpresarialDesc;
  int? lojaId;
  int? fornecedorId;
  int? motoristaId;
  DateTime? dtChegada;
  DateTime? dtPrevisaoEntrada;
  DateTime? dtEntrada;
  DateTime? dtInicio;
  DateTime? dtTermino;
  DateTime? dtCancelado;
  String? status;
  String? statusDesc;
  String? docaDesc;
  int? docaId;
  int? veiculoId;
  int? veiculoPlaca;
  int? veiculoTipoId;
  int? prioridade;
  String? lojaDesc;
  String? motoristaNome;
  String? veiculoTipoDesc;
  bool? isSaved;
  // end FIELDS (Checkin)

// COLLECTIONS & VIRTUALS (Checkin)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plNf_compras', 'plField2'..]) or so on..
  List<Nf_compra>? plNf_compras;

  /// get Nf_compra(s) filtered by id=id_checkin
  Nf_compraFilterBuilder? getNf_compras(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Nf_compra()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .id_checkin
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Checkin)

  static const bool _softDeleteActivated = false;
  CheckinManager? __mnCheckin;

  CheckinManager get _mnCheckin {
    return __mnCheckin = __mnCheckin ?? CheckinManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (grupoEmpresarialId != null || !forView) {
      map['grupoEmpresarialId'] = grupoEmpresarialId;
    }
    if (fornecedorDesc != null || !forView) {
      map['fornecedorDesc'] = fornecedorDesc;
    }
    if (grupoEmpresarialDesc != null || !forView) {
      map['grupoEmpresarialDesc'] = grupoEmpresarialDesc;
    }
    if (lojaId != null || !forView) {
      map['lojaId'] = lojaId;
    }
    if (fornecedorId != null || !forView) {
      map['fornecedorId'] = fornecedorId;
    }
    if (motoristaId != null || !forView) {
      map['motoristaId'] = motoristaId;
    }
    if (dtChegada != null) {
      map['dtChegada'] = forJson
          ? dtChegada!.toString()
          : forQuery
              ? dtChegada!.millisecondsSinceEpoch
              : dtChegada;
    } else if (dtChegada != null || !forView) {
      map['dtChegada'] = null;
    }
    if (dtPrevisaoEntrada != null) {
      map['dtPrevisaoEntrada'] = forJson
          ? dtPrevisaoEntrada!.toString()
          : forQuery
              ? dtPrevisaoEntrada!.millisecondsSinceEpoch
              : dtPrevisaoEntrada;
    } else if (dtPrevisaoEntrada != null || !forView) {
      map['dtPrevisaoEntrada'] = null;
    }
    if (dtEntrada != null) {
      map['dtEntrada'] = forJson
          ? dtEntrada!.toString()
          : forQuery
              ? dtEntrada!.millisecondsSinceEpoch
              : dtEntrada;
    } else if (dtEntrada != null || !forView) {
      map['dtEntrada'] = null;
    }
    if (dtInicio != null) {
      map['dtInicio'] = forJson
          ? dtInicio!.toString()
          : forQuery
              ? dtInicio!.millisecondsSinceEpoch
              : dtInicio;
    } else if (dtInicio != null || !forView) {
      map['dtInicio'] = null;
    }
    if (dtTermino != null) {
      map['dtTermino'] = forJson
          ? dtTermino!.toString()
          : forQuery
              ? dtTermino!.millisecondsSinceEpoch
              : dtTermino;
    } else if (dtTermino != null || !forView) {
      map['dtTermino'] = null;
    }
    if (dtCancelado != null) {
      map['dtCancelado'] = forJson
          ? dtCancelado!.toString()
          : forQuery
              ? dtCancelado!.millisecondsSinceEpoch
              : dtCancelado;
    } else if (dtCancelado != null || !forView) {
      map['dtCancelado'] = null;
    }
    if (status != null || !forView) {
      map['status'] = status;
    }
    if (statusDesc != null || !forView) {
      map['statusDesc'] = statusDesc;
    }
    if (docaDesc != null || !forView) {
      map['docaDesc'] = docaDesc;
    }
    if (docaId != null || !forView) {
      map['docaId'] = docaId;
    }
    if (veiculoId != null || !forView) {
      map['veiculoId'] = veiculoId;
    }
    if (veiculoPlaca != null || !forView) {
      map['veiculoPlaca'] = veiculoPlaca;
    }
    if (veiculoTipoId != null || !forView) {
      map['veiculoTipoId'] = veiculoTipoId;
    }
    if (prioridade != null || !forView) {
      map['prioridade'] = prioridade;
    }
    if (lojaDesc != null || !forView) {
      map['lojaDesc'] = lojaDesc;
    }
    if (motoristaNome != null || !forView) {
      map['motoristaNome'] = motoristaNome;
    }
    if (veiculoTipoDesc != null || !forView) {
      map['veiculoTipoDesc'] = veiculoTipoDesc;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (grupoEmpresarialId != null || !forView) {
      map['grupoEmpresarialId'] = grupoEmpresarialId;
    }
    if (fornecedorDesc != null || !forView) {
      map['fornecedorDesc'] = fornecedorDesc;
    }
    if (grupoEmpresarialDesc != null || !forView) {
      map['grupoEmpresarialDesc'] = grupoEmpresarialDesc;
    }
    if (lojaId != null || !forView) {
      map['lojaId'] = lojaId;
    }
    if (fornecedorId != null || !forView) {
      map['fornecedorId'] = fornecedorId;
    }
    if (motoristaId != null || !forView) {
      map['motoristaId'] = motoristaId;
    }
    if (dtChegada != null) {
      map['dtChegada'] = forJson
          ? dtChegada!.toString()
          : forQuery
              ? dtChegada!.millisecondsSinceEpoch
              : dtChegada;
    } else if (dtChegada != null || !forView) {
      map['dtChegada'] = null;
    }
    if (dtPrevisaoEntrada != null) {
      map['dtPrevisaoEntrada'] = forJson
          ? dtPrevisaoEntrada!.toString()
          : forQuery
              ? dtPrevisaoEntrada!.millisecondsSinceEpoch
              : dtPrevisaoEntrada;
    } else if (dtPrevisaoEntrada != null || !forView) {
      map['dtPrevisaoEntrada'] = null;
    }
    if (dtEntrada != null) {
      map['dtEntrada'] = forJson
          ? dtEntrada!.toString()
          : forQuery
              ? dtEntrada!.millisecondsSinceEpoch
              : dtEntrada;
    } else if (dtEntrada != null || !forView) {
      map['dtEntrada'] = null;
    }
    if (dtInicio != null) {
      map['dtInicio'] = forJson
          ? dtInicio!.toString()
          : forQuery
              ? dtInicio!.millisecondsSinceEpoch
              : dtInicio;
    } else if (dtInicio != null || !forView) {
      map['dtInicio'] = null;
    }
    if (dtTermino != null) {
      map['dtTermino'] = forJson
          ? dtTermino!.toString()
          : forQuery
              ? dtTermino!.millisecondsSinceEpoch
              : dtTermino;
    } else if (dtTermino != null || !forView) {
      map['dtTermino'] = null;
    }
    if (dtCancelado != null) {
      map['dtCancelado'] = forJson
          ? dtCancelado!.toString()
          : forQuery
              ? dtCancelado!.millisecondsSinceEpoch
              : dtCancelado;
    } else if (dtCancelado != null || !forView) {
      map['dtCancelado'] = null;
    }
    if (status != null || !forView) {
      map['status'] = status;
    }
    if (statusDesc != null || !forView) {
      map['statusDesc'] = statusDesc;
    }
    if (docaDesc != null || !forView) {
      map['docaDesc'] = docaDesc;
    }
    if (docaId != null || !forView) {
      map['docaId'] = docaId;
    }
    if (veiculoId != null || !forView) {
      map['veiculoId'] = veiculoId;
    }
    if (veiculoPlaca != null || !forView) {
      map['veiculoPlaca'] = veiculoPlaca;
    }
    if (veiculoTipoId != null || !forView) {
      map['veiculoTipoId'] = veiculoTipoId;
    }
    if (prioridade != null || !forView) {
      map['prioridade'] = prioridade;
    }
    if (lojaDesc != null || !forView) {
      map['lojaDesc'] = lojaDesc;
    }
    if (motoristaNome != null || !forView) {
      map['motoristaNome'] = motoristaNome;
    }
    if (veiculoTipoDesc != null || !forView) {
      map['veiculoTipoDesc'] = veiculoTipoDesc;
    }

// COLLECTIONS (Checkin)
    if (!forQuery) {
      map['Nf_compras'] = await getNf_compras()!.toMapList();
    }
// END COLLECTIONS (Checkin)

    return map;
  }

  /// This method returns Json String [Checkin]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Checkin]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      id,
      grupoEmpresarialId,
      fornecedorDesc,
      grupoEmpresarialDesc,
      lojaId,
      fornecedorId,
      motoristaId,
      dtChegada != null ? dtChegada!.millisecondsSinceEpoch : null,
      dtPrevisaoEntrada != null
          ? dtPrevisaoEntrada!.millisecondsSinceEpoch
          : null,
      dtEntrada != null ? dtEntrada!.millisecondsSinceEpoch : null,
      dtInicio != null ? dtInicio!.millisecondsSinceEpoch : null,
      dtTermino != null ? dtTermino!.millisecondsSinceEpoch : null,
      dtCancelado != null ? dtCancelado!.millisecondsSinceEpoch : null,
      status,
      statusDesc,
      docaDesc,
      docaId,
      veiculoId,
      veiculoPlaca,
      veiculoTipoId,
      prioridade,
      lojaDesc,
      motoristaNome,
      veiculoTipoDesc
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      grupoEmpresarialId,
      fornecedorDesc,
      grupoEmpresarialDesc,
      lojaId,
      fornecedorId,
      motoristaId,
      dtChegada != null ? dtChegada!.millisecondsSinceEpoch : null,
      dtPrevisaoEntrada != null
          ? dtPrevisaoEntrada!.millisecondsSinceEpoch
          : null,
      dtEntrada != null ? dtEntrada!.millisecondsSinceEpoch : null,
      dtInicio != null ? dtInicio!.millisecondsSinceEpoch : null,
      dtTermino != null ? dtTermino!.millisecondsSinceEpoch : null,
      dtCancelado != null ? dtCancelado!.millisecondsSinceEpoch : null,
      status,
      statusDesc,
      docaDesc,
      docaId,
      veiculoId,
      veiculoPlaca,
      veiculoTipoId,
      prioridade,
      lojaDesc,
      motoristaNome,
      veiculoTipoDesc
    ];
  }

  static Future<List<Checkin>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Checkin.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Checkin>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Checkin>[];
    try {
      objList = list
          .map((checkin) => Checkin.fromMap(checkin as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Checkin.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Checkin>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Checkin> objList = <Checkin>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Checkin.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('checkin.plNf_compras') && */ (preloadFields ==
                null ||
            preloadFields.contains('plNf_compras'))) {
          /*_loadedfields!.add('checkin.plNf_compras'); */ obj.plNf_compras =
              obj.plNf_compras ??
                  await obj.getNf_compras()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Checkin by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Checkin] if exist, otherwise returns null
  Future<Checkin?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Checkin? obj;
    final data = await _mnCheckin.getById([id]);
    if (data.length != 0) {
      obj = Checkin.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('checkin.plNf_compras') && */ (preloadFields ==
                null ||
            preloadFields.contains('plNf_compras'))) {
          /*_loadedfields!.add('checkin.plNf_compras'); */ obj.plNf_compras =
              obj.plNf_compras ??
                  await obj.getNf_compras()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Checkin) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnCheckin.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnCheckin.update(this);
    }

    return id;
  }

  /// Saves the (Checkin) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnCheckin.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCheckin.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Checkin> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Checkin> checkins,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in checkins) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCheckin.rawInsert(
          'INSERT OR REPLACE INTO checkin (id, grupoEmpresarialId, fornecedorDesc, grupoEmpresarialDesc, lojaId, fornecedorId, motoristaId, dtChegada, dtPrevisaoEntrada, dtEntrada, dtInicio, dtTermino, dtCancelado, status, statusDesc, docaDesc, docaId, veiculoId, veiculoPlaca, veiculoTipoId, prioridade, lojaDesc, motoristaNome, veiculoTipoDesc)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            grupoEmpresarialId,
            fornecedorDesc,
            grupoEmpresarialDesc,
            lojaId,
            fornecedorId,
            motoristaId,
            dtChegada != null ? dtChegada!.millisecondsSinceEpoch : null,
            dtPrevisaoEntrada != null
                ? dtPrevisaoEntrada!.millisecondsSinceEpoch
                : null,
            dtEntrada != null ? dtEntrada!.millisecondsSinceEpoch : null,
            dtInicio != null ? dtInicio!.millisecondsSinceEpoch : null,
            dtTermino != null ? dtTermino!.millisecondsSinceEpoch : null,
            dtCancelado != null ? dtCancelado!.millisecondsSinceEpoch : null,
            status,
            statusDesc,
            docaDesc,
            docaId,
            veiculoId,
            veiculoPlaca,
            veiculoTipoId,
            prioridade,
            lojaDesc,
            motoristaNome,
            veiculoTipoDesc
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Checkin id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Checkin id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Checkin Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Checkin>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Checkin> checkins,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnCheckin.rawInsertAll(
        'INSERT OR REPLACE INTO checkin (id, grupoEmpresarialId, fornecedorDesc, grupoEmpresarialDesc, lojaId, fornecedorId, motoristaId, dtChegada, dtPrevisaoEntrada, dtEntrada, dtInicio, dtTermino, dtCancelado, status, statusDesc, docaDesc, docaId, veiculoId, veiculoPlaca, veiculoTipoId, prioridade, lojaDesc, motoristaNome, veiculoTipoDesc)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        checkins,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Checkin

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Checkin invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await Nf_compra()
          .select()
          .id_checkin
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnCheckin
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnCheckin.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Checkin] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  CheckinFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CheckinFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CheckinFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CheckinFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion checkin

// region CheckinField
class CheckinField extends FilterBase {
  CheckinField(CheckinFilterBuilder checkinFB) : super(checkinFB);

  @override
  CheckinFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CheckinFilterBuilder;
  }

  @override
  CheckinFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CheckinFilterBuilder;
  }

  @override
  CheckinFilterBuilder isNull() {
    return super.isNull() as CheckinFilterBuilder;
  }

  @override
  CheckinFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CheckinFilterBuilder;
  }

  @override
  CheckinFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CheckinFilterBuilder;
  }

  @override
  CheckinFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CheckinFilterBuilder;
  }

  @override
  CheckinFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CheckinFilterBuilder;
  }

  @override
  CheckinFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CheckinFilterBuilder;
  }

  @override
  CheckinFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CheckinFilterBuilder;
  }

  @override
  CheckinFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CheckinFilterBuilder;
  }

  @override
  CheckinFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CheckinFilterBuilder;
  }

  @override
  CheckinFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CheckinFilterBuilder;
  }

  @override
  CheckinField get not {
    return super.not as CheckinField;
  }
}
// endregion CheckinField

// region CheckinFilterBuilder
class CheckinFilterBuilder extends ConjunctionBase {
  CheckinFilterBuilder(Checkin obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCheckin = obj._mnCheckin;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CheckinManager? _mnCheckin;

  /// put the sql keyword 'AND'
  @override
  CheckinFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CheckinFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CheckinFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CheckinFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CheckinFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CheckinFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CheckinFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CheckinFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CheckinFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CheckinFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CheckinFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CheckinField _setField(CheckinField? field, String colName, DbType dbtype) {
    return CheckinField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CheckinField? _id;
  CheckinField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  CheckinField? _grupoEmpresarialId;
  CheckinField get grupoEmpresarialId {
    return _grupoEmpresarialId =
        _setField(_grupoEmpresarialId, 'grupoEmpresarialId', DbType.integer);
  }

  CheckinField? _fornecedorDesc;
  CheckinField get fornecedorDesc {
    return _fornecedorDesc =
        _setField(_fornecedorDesc, 'fornecedorDesc', DbType.text);
  }

  CheckinField? _grupoEmpresarialDesc;
  CheckinField get grupoEmpresarialDesc {
    return _grupoEmpresarialDesc =
        _setField(_grupoEmpresarialDesc, 'grupoEmpresarialDesc', DbType.text);
  }

  CheckinField? _lojaId;
  CheckinField get lojaId {
    return _lojaId = _setField(_lojaId, 'lojaId', DbType.integer);
  }

  CheckinField? _fornecedorId;
  CheckinField get fornecedorId {
    return _fornecedorId =
        _setField(_fornecedorId, 'fornecedorId', DbType.integer);
  }

  CheckinField? _motoristaId;
  CheckinField get motoristaId {
    return _motoristaId =
        _setField(_motoristaId, 'motoristaId', DbType.integer);
  }

  CheckinField? _dtChegada;
  CheckinField get dtChegada {
    return _dtChegada = _setField(_dtChegada, 'dtChegada', DbType.datetime);
  }

  CheckinField? _dtPrevisaoEntrada;
  CheckinField get dtPrevisaoEntrada {
    return _dtPrevisaoEntrada =
        _setField(_dtPrevisaoEntrada, 'dtPrevisaoEntrada', DbType.datetime);
  }

  CheckinField? _dtEntrada;
  CheckinField get dtEntrada {
    return _dtEntrada = _setField(_dtEntrada, 'dtEntrada', DbType.datetime);
  }

  CheckinField? _dtInicio;
  CheckinField get dtInicio {
    return _dtInicio = _setField(_dtInicio, 'dtInicio', DbType.datetime);
  }

  CheckinField? _dtTermino;
  CheckinField get dtTermino {
    return _dtTermino = _setField(_dtTermino, 'dtTermino', DbType.datetime);
  }

  CheckinField? _dtCancelado;
  CheckinField get dtCancelado {
    return _dtCancelado =
        _setField(_dtCancelado, 'dtCancelado', DbType.datetime);
  }

  CheckinField? _status;
  CheckinField get status {
    return _status = _setField(_status, 'status', DbType.text);
  }

  CheckinField? _statusDesc;
  CheckinField get statusDesc {
    return _statusDesc = _setField(_statusDesc, 'statusDesc', DbType.text);
  }

  CheckinField? _docaDesc;
  CheckinField get docaDesc {
    return _docaDesc = _setField(_docaDesc, 'docaDesc', DbType.text);
  }

  CheckinField? _docaId;
  CheckinField get docaId {
    return _docaId = _setField(_docaId, 'docaId', DbType.integer);
  }

  CheckinField? _veiculoId;
  CheckinField get veiculoId {
    return _veiculoId = _setField(_veiculoId, 'veiculoId', DbType.integer);
  }

  CheckinField? _veiculoPlaca;
  CheckinField get veiculoPlaca {
    return _veiculoPlaca =
        _setField(_veiculoPlaca, 'veiculoPlaca', DbType.integer);
  }

  CheckinField? _veiculoTipoId;
  CheckinField get veiculoTipoId {
    return _veiculoTipoId =
        _setField(_veiculoTipoId, 'veiculoTipoId', DbType.integer);
  }

  CheckinField? _prioridade;
  CheckinField get prioridade {
    return _prioridade = _setField(_prioridade, 'prioridade', DbType.integer);
  }

  CheckinField? _lojaDesc;
  CheckinField get lojaDesc {
    return _lojaDesc = _setField(_lojaDesc, 'lojaDesc', DbType.text);
  }

  CheckinField? _motoristaNome;
  CheckinField get motoristaNome {
    return _motoristaNome =
        _setField(_motoristaNome, 'motoristaNome', DbType.text);
  }

  CheckinField? _veiculoTipoDesc;
  CheckinField get veiculoTipoDesc {
    return _veiculoTipoDesc =
        _setField(_veiculoTipoDesc, 'veiculoTipoDesc', DbType.text);
  }

  /// Deletes List<Checkin> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (Nf_compra) according to DeleteRule.CASCADE
    final idListNf_compraBYid_checkin = toListPrimaryKeySQL(false);
    final resNf_compraBYid_checkin = await Nf_compra()
        .select()
        .where('id_checkin IN (${idListNf_compraBYid_checkin['sql']})',
            parameterValue: idListNf_compraBYid_checkin['args'])
        .delete(hardDelete);
    if (!resNf_compraBYid_checkin.success) {
      return resNf_compraBYid_checkin;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCheckin!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCheckin!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from checkin ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCheckin!.updateBatch(qparams, values);
  }

  /// This method always returns [Checkin] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Checkin?
  @override
  Future<Checkin?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCheckin!.toList(qparams);
    final data = await objFuture;
    Checkin? obj;
    if (data.isNotEmpty) {
      obj = Checkin.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('checkin.plNf_compras') && */ (preloadFields ==
                null ||
            preloadFields.contains('plNf_compras'))) {
          /*_loadedfields!.add('checkin.plNf_compras'); */ obj.plNf_compras =
              obj.plNf_compras ??
                  await obj.getNf_compras()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Checkin]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Checkin?
  @override
  Future<Checkin> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Checkin();
  }

  /// This method returns int. [Checkin]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? checkinCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final checkinsFuture = await _mnCheckin!.toList(qparams);
    final int count = checkinsFuture[0]['CNT'] as int;
    if (checkinCount != null) {
      checkinCount(count);
    }
    return count;
  }

  /// This method returns List<Checkin> [Checkin]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Checkin>
  @override
  Future<List<Checkin>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Checkin> checkinsData = await Checkin.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return checkinsData;
  }

  /// This method returns Json String [Checkin]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Checkin]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Checkin]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCheckin!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Checkin]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM checkin WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnCheckin!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Checkin]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCheckin!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Checkin.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCheckin!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CheckinFilterBuilder

// region CheckinFields
class CheckinFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fGrupoEmpresarialId;
  static TableField get grupoEmpresarialId {
    return _fGrupoEmpresarialId = _fGrupoEmpresarialId ??
        SqlSyntax.setField(
            _fGrupoEmpresarialId, 'grupoEmpresarialId', DbType.integer);
  }

  static TableField? _fFornecedorDesc;
  static TableField get fornecedorDesc {
    return _fFornecedorDesc = _fFornecedorDesc ??
        SqlSyntax.setField(_fFornecedorDesc, 'fornecedorDesc', DbType.text);
  }

  static TableField? _fGrupoEmpresarialDesc;
  static TableField get grupoEmpresarialDesc {
    return _fGrupoEmpresarialDesc = _fGrupoEmpresarialDesc ??
        SqlSyntax.setField(
            _fGrupoEmpresarialDesc, 'grupoEmpresarialDesc', DbType.text);
  }

  static TableField? _fLojaId;
  static TableField get lojaId {
    return _fLojaId =
        _fLojaId ?? SqlSyntax.setField(_fLojaId, 'lojaId', DbType.integer);
  }

  static TableField? _fFornecedorId;
  static TableField get fornecedorId {
    return _fFornecedorId = _fFornecedorId ??
        SqlSyntax.setField(_fFornecedorId, 'fornecedorId', DbType.integer);
  }

  static TableField? _fMotoristaId;
  static TableField get motoristaId {
    return _fMotoristaId = _fMotoristaId ??
        SqlSyntax.setField(_fMotoristaId, 'motoristaId', DbType.integer);
  }

  static TableField? _fDtChegada;
  static TableField get dtChegada {
    return _fDtChegada = _fDtChegada ??
        SqlSyntax.setField(_fDtChegada, 'dtChegada', DbType.datetime);
  }

  static TableField? _fDtPrevisaoEntrada;
  static TableField get dtPrevisaoEntrada {
    return _fDtPrevisaoEntrada = _fDtPrevisaoEntrada ??
        SqlSyntax.setField(
            _fDtPrevisaoEntrada, 'dtPrevisaoEntrada', DbType.datetime);
  }

  static TableField? _fDtEntrada;
  static TableField get dtEntrada {
    return _fDtEntrada = _fDtEntrada ??
        SqlSyntax.setField(_fDtEntrada, 'dtEntrada', DbType.datetime);
  }

  static TableField? _fDtInicio;
  static TableField get dtInicio {
    return _fDtInicio = _fDtInicio ??
        SqlSyntax.setField(_fDtInicio, 'dtInicio', DbType.datetime);
  }

  static TableField? _fDtTermino;
  static TableField get dtTermino {
    return _fDtTermino = _fDtTermino ??
        SqlSyntax.setField(_fDtTermino, 'dtTermino', DbType.datetime);
  }

  static TableField? _fDtCancelado;
  static TableField get dtCancelado {
    return _fDtCancelado = _fDtCancelado ??
        SqlSyntax.setField(_fDtCancelado, 'dtCancelado', DbType.datetime);
  }

  static TableField? _fStatus;
  static TableField get status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'status', DbType.text);
  }

  static TableField? _fStatusDesc;
  static TableField get statusDesc {
    return _fStatusDesc = _fStatusDesc ??
        SqlSyntax.setField(_fStatusDesc, 'statusDesc', DbType.text);
  }

  static TableField? _fDocaDesc;
  static TableField get docaDesc {
    return _fDocaDesc =
        _fDocaDesc ?? SqlSyntax.setField(_fDocaDesc, 'docaDesc', DbType.text);
  }

  static TableField? _fDocaId;
  static TableField get docaId {
    return _fDocaId =
        _fDocaId ?? SqlSyntax.setField(_fDocaId, 'docaId', DbType.integer);
  }

  static TableField? _fVeiculoId;
  static TableField get veiculoId {
    return _fVeiculoId = _fVeiculoId ??
        SqlSyntax.setField(_fVeiculoId, 'veiculoId', DbType.integer);
  }

  static TableField? _fVeiculoPlaca;
  static TableField get veiculoPlaca {
    return _fVeiculoPlaca = _fVeiculoPlaca ??
        SqlSyntax.setField(_fVeiculoPlaca, 'veiculoPlaca', DbType.integer);
  }

  static TableField? _fVeiculoTipoId;
  static TableField get veiculoTipoId {
    return _fVeiculoTipoId = _fVeiculoTipoId ??
        SqlSyntax.setField(_fVeiculoTipoId, 'veiculoTipoId', DbType.integer);
  }

  static TableField? _fPrioridade;
  static TableField get prioridade {
    return _fPrioridade = _fPrioridade ??
        SqlSyntax.setField(_fPrioridade, 'prioridade', DbType.integer);
  }

  static TableField? _fLojaDesc;
  static TableField get lojaDesc {
    return _fLojaDesc =
        _fLojaDesc ?? SqlSyntax.setField(_fLojaDesc, 'lojaDesc', DbType.text);
  }

  static TableField? _fMotoristaNome;
  static TableField get motoristaNome {
    return _fMotoristaNome = _fMotoristaNome ??
        SqlSyntax.setField(_fMotoristaNome, 'motoristaNome', DbType.text);
  }

  static TableField? _fVeiculoTipoDesc;
  static TableField get veiculoTipoDesc {
    return _fVeiculoTipoDesc = _fVeiculoTipoDesc ??
        SqlSyntax.setField(_fVeiculoTipoDesc, 'veiculoTipoDesc', DbType.text);
  }
}
// endregion CheckinFields

//region CheckinManager
class CheckinManager extends SqfEntityProvider {
  CheckinManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'checkin';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion CheckinManager
// region Nf_compra
class Nf_compra extends TableBase {
  Nf_compra(
      {this.id,
      this.chaveNf,
      this.fornecedorDesc,
      this.valorTotal,
      this.statusDesc,
      this.id_checkin,
      this.numNf,
      this.serieNf,
      this.dtCadastro,
      this.status,
      this.dtEntrada,
      this.erpId,
      this.fornecedorId,
      this.lojaId,
      this.excluida,
      this.dtEmissao}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Nf_compra.withFields(
      this.id,
      this.chaveNf,
      this.fornecedorDesc,
      this.valorTotal,
      this.statusDesc,
      this.id_checkin,
      this.numNf,
      this.serieNf,
      this.dtCadastro,
      this.status,
      this.dtEntrada,
      this.erpId,
      this.fornecedorId,
      this.lojaId,
      this.excluida,
      this.dtEmissao) {
    _setDefaultValues();
  }
  Nf_compra.withId(
      this.id,
      this.chaveNf,
      this.fornecedorDesc,
      this.valorTotal,
      this.statusDesc,
      this.id_checkin,
      this.numNf,
      this.serieNf,
      this.dtCadastro,
      this.status,
      this.dtEntrada,
      this.erpId,
      this.fornecedorId,
      this.lojaId,
      this.excluida,
      this.dtEmissao) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Nf_compra.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['chaveNf'] != null) {
      chaveNf = o['chaveNf'].toString();
    }
    if (o['fornecedorDesc'] != null) {
      fornecedorDesc = o['fornecedorDesc'].toString();
    }
    if (o['valorTotal'] != null) {
      valorTotal = double.tryParse(o['valorTotal'].toString());
    }
    if (o['statusDesc'] != null) {
      statusDesc = o['statusDesc'].toString();
    }
    id_checkin = int.tryParse(o['id_checkin'].toString());

    if (o['numNf'] != null) {
      numNf = o['numNf'].toString();
    }
    if (o['serieNf'] != null) {
      serieNf = o['serieNf'].toString();
    }
    if (o['dtCadastro'] != null) {
      dtCadastro = o['dtCadastro'].toString();
    }
    if (o['status'] != null) {
      status = o['status'].toString();
    }
    if (o['dtEntrada'] != null) {
      dtEntrada = int.tryParse(o['dtEntrada'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dtEntrada'].toString())!)
          : DateTime.tryParse(o['dtEntrada'].toString());
    }
    if (o['erpId'] != null) {
      erpId = int.tryParse(o['erpId'].toString());
    }
    if (o['fornecedorId'] != null) {
      fornecedorId = int.tryParse(o['fornecedorId'].toString());
    }
    if (o['lojaId'] != null) {
      lojaId = int.tryParse(o['lojaId'].toString());
    }
    if (o['excluida'] != null) {
      excluida =
          o['excluida'].toString() == '1' || o['excluida'].toString() == 'true';
    }
    if (o['dtEmissao'] != null) {
      dtEmissao = o['dtEmissao'].toString();
    }

    // RELATIONSHIPS FromMAP
    plCheckin = o['checkin'] != null
        ? Checkin.fromMap(o['checkin'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Nf_compra)
  int? id;
  String? chaveNf;
  String? fornecedorDesc;
  double? valorTotal;
  String? statusDesc;
  int? id_checkin;
  String? numNf;
  String? serieNf;
  String? dtCadastro;
  String? status;
  DateTime? dtEntrada;
  int? erpId;
  int? fornecedorId;
  int? lojaId;
  bool? excluida;
  String? dtEmissao;
  bool? isSaved;
  // end FIELDS (Nf_compra)

// RELATIONSHIPS (Nf_compra)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plCheckin', 'plField2'..]) or so on..
  Checkin? plCheckin;

  /// get Checkin By Id_checkin
  Future<Checkin?> getCheckin(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Checkin().getById(id_checkin,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Nf_compra)

  static const bool _softDeleteActivated = false;
  Nf_compraManager? __mnNf_compra;

  Nf_compraManager get _mnNf_compra {
    return __mnNf_compra = __mnNf_compra ?? Nf_compraManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (chaveNf != null || !forView) {
      map['chaveNf'] = chaveNf;
    }
    if (fornecedorDesc != null || !forView) {
      map['fornecedorDesc'] = fornecedorDesc;
    }
    if (valorTotal != null || !forView) {
      map['valorTotal'] = valorTotal;
    }
    if (statusDesc != null || !forView) {
      map['statusDesc'] = statusDesc;
    }
    if (id_checkin != null) {
      map['id_checkin'] = forView
          ? plCheckin == null
              ? id_checkin
              : plCheckin!.fornecedorDesc
          : id_checkin;
    } else if (id_checkin != null || !forView) {
      map['id_checkin'] = null;
    }
    if (numNf != null || !forView) {
      map['numNf'] = numNf;
    }
    if (serieNf != null || !forView) {
      map['serieNf'] = serieNf;
    }
    if (dtCadastro != null || !forView) {
      map['dtCadastro'] = dtCadastro;
    }
    if (status != null || !forView) {
      map['status'] = status;
    }
    if (dtEntrada != null) {
      map['dtEntrada'] = forJson
          ? dtEntrada!.toString()
          : forQuery
              ? dtEntrada!.millisecondsSinceEpoch
              : dtEntrada;
    } else if (dtEntrada != null || !forView) {
      map['dtEntrada'] = null;
    }
    if (erpId != null || !forView) {
      map['erpId'] = erpId;
    }
    if (fornecedorId != null || !forView) {
      map['fornecedorId'] = fornecedorId;
    }
    if (lojaId != null || !forView) {
      map['lojaId'] = lojaId;
    }
    if (excluida != null) {
      map['excluida'] = forQuery ? (excluida! ? 1 : 0) : excluida;
    } else if (excluida != null || !forView) {
      map['excluida'] = null;
    }
    if (dtEmissao != null || !forView) {
      map['dtEmissao'] = dtEmissao;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (chaveNf != null || !forView) {
      map['chaveNf'] = chaveNf;
    }
    if (fornecedorDesc != null || !forView) {
      map['fornecedorDesc'] = fornecedorDesc;
    }
    if (valorTotal != null || !forView) {
      map['valorTotal'] = valorTotal;
    }
    if (statusDesc != null || !forView) {
      map['statusDesc'] = statusDesc;
    }
    if (id_checkin != null) {
      map['id_checkin'] = forView
          ? plCheckin == null
              ? id_checkin
              : plCheckin!.fornecedorDesc
          : id_checkin;
    } else if (id_checkin != null || !forView) {
      map['id_checkin'] = null;
    }
    if (numNf != null || !forView) {
      map['numNf'] = numNf;
    }
    if (serieNf != null || !forView) {
      map['serieNf'] = serieNf;
    }
    if (dtCadastro != null || !forView) {
      map['dtCadastro'] = dtCadastro;
    }
    if (status != null || !forView) {
      map['status'] = status;
    }
    if (dtEntrada != null) {
      map['dtEntrada'] = forJson
          ? dtEntrada!.toString()
          : forQuery
              ? dtEntrada!.millisecondsSinceEpoch
              : dtEntrada;
    } else if (dtEntrada != null || !forView) {
      map['dtEntrada'] = null;
    }
    if (erpId != null || !forView) {
      map['erpId'] = erpId;
    }
    if (fornecedorId != null || !forView) {
      map['fornecedorId'] = fornecedorId;
    }
    if (lojaId != null || !forView) {
      map['lojaId'] = lojaId;
    }
    if (excluida != null) {
      map['excluida'] = forQuery ? (excluida! ? 1 : 0) : excluida;
    } else if (excluida != null || !forView) {
      map['excluida'] = null;
    }
    if (dtEmissao != null || !forView) {
      map['dtEmissao'] = dtEmissao;
    }

    return map;
  }

  /// This method returns Json String [Nf_compra]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Nf_compra]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      id,
      chaveNf,
      fornecedorDesc,
      valorTotal,
      statusDesc,
      id_checkin,
      numNf,
      serieNf,
      dtCadastro,
      status,
      dtEntrada != null ? dtEntrada!.millisecondsSinceEpoch : null,
      erpId,
      fornecedorId,
      lojaId,
      excluida,
      dtEmissao
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      chaveNf,
      fornecedorDesc,
      valorTotal,
      statusDesc,
      id_checkin,
      numNf,
      serieNf,
      dtCadastro,
      status,
      dtEntrada != null ? dtEntrada!.millisecondsSinceEpoch : null,
      erpId,
      fornecedorId,
      lojaId,
      excluida,
      dtEmissao
    ];
  }

  static Future<List<Nf_compra>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Nf_compra.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Nf_compra>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Nf_compra>[];
    try {
      objList = list
          .map((nf_compra) =>
              Nf_compra.fromMap(nf_compra as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Nf_compra.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Nf_compra>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Nf_compra> objList = <Nf_compra>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Nf_compra.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plCheckin'))) {
          obj.plCheckin =
              obj.plCheckin ?? await obj.getCheckin(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Nf_compra by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Nf_compra] if exist, otherwise returns null
  Future<Nf_compra?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Nf_compra? obj;
    final data = await _mnNf_compra.getById([id]);
    if (data.length != 0) {
      obj = Nf_compra.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plCheckin'))) {
          obj.plCheckin =
              obj.plCheckin ?? await obj.getCheckin(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Nf_compra) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnNf_compra.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnNf_compra.update(this);
    }

    return id;
  }

  /// Saves the (Nf_compra) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnNf_compra.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnNf_compra.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Nf_compra> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Nf_compra> nf_compras,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in nf_compras) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnNf_compra.rawInsert(
          'INSERT OR REPLACE INTO nf_compra (id, chaveNf, fornecedorDesc, valorTotal, statusDesc, id_checkin, numNf, serieNf, dtCadastro, status, dtEntrada, erpId, fornecedorId, lojaId, excluida, dtEmissao)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            chaveNf,
            fornecedorDesc,
            valorTotal,
            statusDesc,
            id_checkin,
            numNf,
            serieNf,
            dtCadastro,
            status,
            dtEntrada != null ? dtEntrada!.millisecondsSinceEpoch : null,
            erpId,
            fornecedorId,
            lojaId,
            excluida,
            dtEmissao
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Nf_compra id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Nf_compra id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Nf_compra Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Nf_compra>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Nf_compra> nf_compras,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnNf_compra.rawInsertAll(
        'INSERT OR REPLACE INTO nf_compra (id, chaveNf, fornecedorDesc, valorTotal, statusDesc, id_checkin, numNf, serieNf, dtCadastro, status, dtEntrada, erpId, fornecedorId, lojaId, excluida, dtEmissao)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        nf_compras,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Nf_compra

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Nf_compra invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnNf_compra
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnNf_compra.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Nf_compra] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Nf_compraFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Nf_compraFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Nf_compraFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Nf_compraFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion nf_compra

// region Nf_compraField
class Nf_compraField extends FilterBase {
  Nf_compraField(Nf_compraFilterBuilder nf_compraFB) : super(nf_compraFB);

  @override
  Nf_compraFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Nf_compraFilterBuilder;
  }

  @override
  Nf_compraFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Nf_compraFilterBuilder;
  }

  @override
  Nf_compraFilterBuilder isNull() {
    return super.isNull() as Nf_compraFilterBuilder;
  }

  @override
  Nf_compraFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Nf_compraFilterBuilder;
  }

  @override
  Nf_compraFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Nf_compraFilterBuilder;
  }

  @override
  Nf_compraFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Nf_compraFilterBuilder;
  }

  @override
  Nf_compraFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Nf_compraFilterBuilder;
  }

  @override
  Nf_compraFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Nf_compraFilterBuilder;
  }

  @override
  Nf_compraFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Nf_compraFilterBuilder;
  }

  @override
  Nf_compraFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Nf_compraFilterBuilder;
  }

  @override
  Nf_compraFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Nf_compraFilterBuilder;
  }

  @override
  Nf_compraFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Nf_compraFilterBuilder;
  }

  @override
  Nf_compraField get not {
    return super.not as Nf_compraField;
  }
}
// endregion Nf_compraField

// region Nf_compraFilterBuilder
class Nf_compraFilterBuilder extends ConjunctionBase {
  Nf_compraFilterBuilder(Nf_compra obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnNf_compra = obj._mnNf_compra;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Nf_compraManager? _mnNf_compra;

  /// put the sql keyword 'AND'
  @override
  Nf_compraFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Nf_compraFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Nf_compraFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Nf_compraFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Nf_compraFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Nf_compraFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Nf_compraFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Nf_compraFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Nf_compraFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Nf_compraFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Nf_compraFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Nf_compraField _setField(
      Nf_compraField? field, String colName, DbType dbtype) {
    return Nf_compraField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Nf_compraField? _id;
  Nf_compraField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  Nf_compraField? _chaveNf;
  Nf_compraField get chaveNf {
    return _chaveNf = _setField(_chaveNf, 'chaveNf', DbType.text);
  }

  Nf_compraField? _fornecedorDesc;
  Nf_compraField get fornecedorDesc {
    return _fornecedorDesc =
        _setField(_fornecedorDesc, 'fornecedorDesc', DbType.text);
  }

  Nf_compraField? _valorTotal;
  Nf_compraField get valorTotal {
    return _valorTotal = _setField(_valorTotal, 'valorTotal', DbType.real);
  }

  Nf_compraField? _statusDesc;
  Nf_compraField get statusDesc {
    return _statusDesc = _setField(_statusDesc, 'statusDesc', DbType.text);
  }

  Nf_compraField? _id_checkin;
  Nf_compraField get id_checkin {
    return _id_checkin = _setField(_id_checkin, 'id_checkin', DbType.integer);
  }

  Nf_compraField? _numNf;
  Nf_compraField get numNf {
    return _numNf = _setField(_numNf, 'numNf', DbType.text);
  }

  Nf_compraField? _serieNf;
  Nf_compraField get serieNf {
    return _serieNf = _setField(_serieNf, 'serieNf', DbType.text);
  }

  Nf_compraField? _dtCadastro;
  Nf_compraField get dtCadastro {
    return _dtCadastro = _setField(_dtCadastro, 'dtCadastro', DbType.text);
  }

  Nf_compraField? _status;
  Nf_compraField get status {
    return _status = _setField(_status, 'status', DbType.text);
  }

  Nf_compraField? _dtEntrada;
  Nf_compraField get dtEntrada {
    return _dtEntrada = _setField(_dtEntrada, 'dtEntrada', DbType.datetime);
  }

  Nf_compraField? _erpId;
  Nf_compraField get erpId {
    return _erpId = _setField(_erpId, 'erpId', DbType.integer);
  }

  Nf_compraField? _fornecedorId;
  Nf_compraField get fornecedorId {
    return _fornecedorId =
        _setField(_fornecedorId, 'fornecedorId', DbType.integer);
  }

  Nf_compraField? _lojaId;
  Nf_compraField get lojaId {
    return _lojaId = _setField(_lojaId, 'lojaId', DbType.integer);
  }

  Nf_compraField? _excluida;
  Nf_compraField get excluida {
    return _excluida = _setField(_excluida, 'excluida', DbType.bool);
  }

  Nf_compraField? _dtEmissao;
  Nf_compraField get dtEmissao {
    return _dtEmissao = _setField(_dtEmissao, 'dtEmissao', DbType.text);
  }

  /// Deletes List<Nf_compra> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnNf_compra!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnNf_compra!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from nf_compra ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnNf_compra!.updateBatch(qparams, values);
  }

  /// This method always returns [Nf_compra] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Nf_compra?
  @override
  Future<Nf_compra?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnNf_compra!.toList(qparams);
    final data = await objFuture;
    Nf_compra? obj;
    if (data.isNotEmpty) {
      obj = Nf_compra.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plCheckin'))) {
          obj.plCheckin =
              obj.plCheckin ?? await obj.getCheckin(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Nf_compra]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Nf_compra?
  @override
  Future<Nf_compra> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Nf_compra();
  }

  /// This method returns int. [Nf_compra]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? nf_compraCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final nf_comprasFuture = await _mnNf_compra!.toList(qparams);
    final int count = nf_comprasFuture[0]['CNT'] as int;
    if (nf_compraCount != null) {
      nf_compraCount(count);
    }
    return count;
  }

  /// This method returns List<Nf_compra> [Nf_compra]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Nf_compra>
  @override
  Future<List<Nf_compra>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Nf_compra> nf_comprasData = await Nf_compra.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return nf_comprasData;
  }

  /// This method returns Json String [Nf_compra]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Nf_compra]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Nf_compra]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnNf_compra!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Nf_compra]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM nf_compra WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnNf_compra!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Nf_compra]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnNf_compra!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Nf_compra.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnNf_compra!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Nf_compraFilterBuilder

// region Nf_compraFields
class Nf_compraFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fChaveNf;
  static TableField get chaveNf {
    return _fChaveNf =
        _fChaveNf ?? SqlSyntax.setField(_fChaveNf, 'chaveNf', DbType.text);
  }

  static TableField? _fFornecedorDesc;
  static TableField get fornecedorDesc {
    return _fFornecedorDesc = _fFornecedorDesc ??
        SqlSyntax.setField(_fFornecedorDesc, 'fornecedorDesc', DbType.text);
  }

  static TableField? _fValorTotal;
  static TableField get valorTotal {
    return _fValorTotal = _fValorTotal ??
        SqlSyntax.setField(_fValorTotal, 'valorTotal', DbType.real);
  }

  static TableField? _fStatusDesc;
  static TableField get statusDesc {
    return _fStatusDesc = _fStatusDesc ??
        SqlSyntax.setField(_fStatusDesc, 'statusDesc', DbType.text);
  }

  static TableField? _fId_checkin;
  static TableField get id_checkin {
    return _fId_checkin = _fId_checkin ??
        SqlSyntax.setField(_fId_checkin, 'id_checkin', DbType.integer);
  }

  static TableField? _fNumNf;
  static TableField get numNf {
    return _fNumNf =
        _fNumNf ?? SqlSyntax.setField(_fNumNf, 'numNf', DbType.text);
  }

  static TableField? _fSerieNf;
  static TableField get serieNf {
    return _fSerieNf =
        _fSerieNf ?? SqlSyntax.setField(_fSerieNf, 'serieNf', DbType.text);
  }

  static TableField? _fDtCadastro;
  static TableField get dtCadastro {
    return _fDtCadastro = _fDtCadastro ??
        SqlSyntax.setField(_fDtCadastro, 'dtCadastro', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'status', DbType.text);
  }

  static TableField? _fDtEntrada;
  static TableField get dtEntrada {
    return _fDtEntrada = _fDtEntrada ??
        SqlSyntax.setField(_fDtEntrada, 'dtEntrada', DbType.datetime);
  }

  static TableField? _fErpId;
  static TableField get erpId {
    return _fErpId =
        _fErpId ?? SqlSyntax.setField(_fErpId, 'erpId', DbType.integer);
  }

  static TableField? _fFornecedorId;
  static TableField get fornecedorId {
    return _fFornecedorId = _fFornecedorId ??
        SqlSyntax.setField(_fFornecedorId, 'fornecedorId', DbType.integer);
  }

  static TableField? _fLojaId;
  static TableField get lojaId {
    return _fLojaId =
        _fLojaId ?? SqlSyntax.setField(_fLojaId, 'lojaId', DbType.integer);
  }

  static TableField? _fExcluida;
  static TableField get excluida {
    return _fExcluida =
        _fExcluida ?? SqlSyntax.setField(_fExcluida, 'excluida', DbType.bool);
  }

  static TableField? _fDtEmissao;
  static TableField get dtEmissao {
    return _fDtEmissao = _fDtEmissao ??
        SqlSyntax.setField(_fDtEmissao, 'dtEmissao', DbType.text);
  }
}
// endregion Nf_compraFields

//region Nf_compraManager
class Nf_compraManager extends SqfEntityProvider {
  Nf_compraManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'nf_compra';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion Nf_compraManager
// region Usuario
class Usuario extends TableBase {
  Usuario(
      {this.id,
      this.id_veiculo,
      this.id_rede,
      this.cpf,
      this.nome,
      this.email,
      this.telefone,
      this.foto,
      this.status}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Usuario.withFields(this.id, this.id_veiculo, this.id_rede, this.cpf,
      this.nome, this.email, this.telefone, this.foto, this.status) {
    _setDefaultValues();
  }
  Usuario.withId(this.id, this.id_veiculo, this.id_rede, this.cpf, this.nome,
      this.email, this.telefone, this.foto, this.status) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Usuario.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    id_veiculo = int.tryParse(o['id_veiculo'].toString());

    id_rede = int.tryParse(o['id_rede'].toString());

    if (o['cpf'] != null) {
      cpf = o['cpf'].toString();
    }
    if (o['nome'] != null) {
      nome = o['nome'].toString();
    }
    if (o['email'] != null) {
      email = o['email'].toString();
    }
    if (o['telefone'] != null) {
      telefone = o['telefone'].toString();
    }
    if (o['foto'] != null) {
      foto = o['foto'].toString();
    }
    if (o['status'] != null) {
      status = o['status'].toString();
    }

    // RELATIONSHIPS FromMAP
    plVeiculo = o['veiculo'] != null
        ? Veiculo.fromMap(o['veiculo'] as Map<String, dynamic>)
        : null;
    plRede = o['rede'] != null
        ? Rede.fromMap(o['rede'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Usuario)
  int? id;
  int? id_veiculo;
  int? id_rede;
  String? cpf;
  String? nome;
  String? email;
  String? telefone;
  String? foto;
  String? status;
  bool? isSaved;
  // end FIELDS (Usuario)

// RELATIONSHIPS (Usuario)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plVeiculo', 'plField2'..]) or so on..
  Veiculo? plVeiculo;

  /// get Veiculo By Id_veiculo
  Future<Veiculo?> getVeiculo(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Veiculo().getById(id_veiculo,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plRede', 'plField2'..]) or so on..
  Rede? plRede;

  /// get Rede By Id_rede
  Future<Rede?> getRede(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Rede()
        .getById(id_rede, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Usuario)

  static const bool _softDeleteActivated = false;
  UsuarioManager? __mnUsuario;

  UsuarioManager get _mnUsuario {
    return __mnUsuario = __mnUsuario ?? UsuarioManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (id_veiculo != null) {
      map['id_veiculo'] = forView
          ? plVeiculo == null
              ? id_veiculo
              : plVeiculo!.tipoVeiculo
          : id_veiculo;
    } else if (id_veiculo != null || !forView) {
      map['id_veiculo'] = null;
    }
    if (id_rede != null) {
      map['id_rede'] = forView
          ? plRede == null
              ? id_rede
              : plRede!.descricao
          : id_rede;
    } else if (id_rede != null || !forView) {
      map['id_rede'] = null;
    }
    if (cpf != null || !forView) {
      map['cpf'] = cpf;
    }
    if (nome != null || !forView) {
      map['nome'] = nome;
    }
    if (email != null || !forView) {
      map['email'] = email;
    }
    if (telefone != null || !forView) {
      map['telefone'] = telefone;
    }
    if (foto != null || !forView) {
      map['foto'] = foto;
    }
    if (status != null || !forView) {
      map['status'] = status;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (id_veiculo != null) {
      map['id_veiculo'] = forView
          ? plVeiculo == null
              ? id_veiculo
              : plVeiculo!.tipoVeiculo
          : id_veiculo;
    } else if (id_veiculo != null || !forView) {
      map['id_veiculo'] = null;
    }
    if (id_rede != null) {
      map['id_rede'] = forView
          ? plRede == null
              ? id_rede
              : plRede!.descricao
          : id_rede;
    } else if (id_rede != null || !forView) {
      map['id_rede'] = null;
    }
    if (cpf != null || !forView) {
      map['cpf'] = cpf;
    }
    if (nome != null || !forView) {
      map['nome'] = nome;
    }
    if (email != null || !forView) {
      map['email'] = email;
    }
    if (telefone != null || !forView) {
      map['telefone'] = telefone;
    }
    if (foto != null || !forView) {
      map['foto'] = foto;
    }
    if (status != null || !forView) {
      map['status'] = status;
    }

    return map;
  }

  /// This method returns Json String [Usuario]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Usuario]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [id, id_veiculo, id_rede, cpf, nome, email, telefone, foto, status];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, id_veiculo, id_rede, cpf, nome, email, telefone, foto, status];
  }

  static Future<List<Usuario>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Usuario.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Usuario>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Usuario>[];
    try {
      objList = list
          .map((usuario) => Usuario.fromMap(usuario as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Usuario.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Usuario>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Usuario> objList = <Usuario>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Usuario.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plVeiculo'))) {
          obj.plVeiculo =
              obj.plVeiculo ?? await obj.getVeiculo(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plRede'))) {
          obj.plRede =
              obj.plRede ?? await obj.getRede(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Usuario by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Usuario] if exist, otherwise returns null
  Future<Usuario?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Usuario? obj;
    final data = await _mnUsuario.getById([id]);
    if (data.length != 0) {
      obj = Usuario.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plVeiculo'))) {
          obj.plVeiculo =
              obj.plVeiculo ?? await obj.getVeiculo(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plRede'))) {
          obj.plRede =
              obj.plRede ?? await obj.getRede(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Usuario) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnUsuario.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnUsuario.update(this);
    }

    return id;
  }

  /// Saves the (Usuario) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnUsuario.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUsuario.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Usuario> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Usuario> usuarios,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in usuarios) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUsuario.rawInsert(
          'INSERT OR REPLACE INTO usuario (id, id_veiculo, id_rede, cpf, nome, email, telefone, foto, status)  VALUES (?,?,?,?,?,?,?,?,?)',
          [id, id_veiculo, id_rede, cpf, nome, email, telefone, foto, status],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Usuario id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Usuario id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Usuario Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Usuario>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Usuario> usuarios,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnUsuario.rawInsertAll(
        'INSERT OR REPLACE INTO usuario (id, id_veiculo, id_rede, cpf, nome, email, telefone, foto, status)  VALUES (?,?,?,?,?,?,?,?,?)',
        usuarios,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Usuario

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Usuario invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnUsuario
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnUsuario.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Usuario] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  UsuarioFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UsuarioFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  UsuarioFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UsuarioFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion usuario

// region UsuarioField
class UsuarioField extends FilterBase {
  UsuarioField(UsuarioFilterBuilder usuarioFB) : super(usuarioFB);

  @override
  UsuarioFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as UsuarioFilterBuilder;
  }

  @override
  UsuarioFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as UsuarioFilterBuilder;
  }

  @override
  UsuarioFilterBuilder isNull() {
    return super.isNull() as UsuarioFilterBuilder;
  }

  @override
  UsuarioFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as UsuarioFilterBuilder;
  }

  @override
  UsuarioFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as UsuarioFilterBuilder;
  }

  @override
  UsuarioFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as UsuarioFilterBuilder;
  }

  @override
  UsuarioFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as UsuarioFilterBuilder;
  }

  @override
  UsuarioFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as UsuarioFilterBuilder;
  }

  @override
  UsuarioFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as UsuarioFilterBuilder;
  }

  @override
  UsuarioFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as UsuarioFilterBuilder;
  }

  @override
  UsuarioFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as UsuarioFilterBuilder;
  }

  @override
  UsuarioFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as UsuarioFilterBuilder;
  }

  @override
  UsuarioField get not {
    return super.not as UsuarioField;
  }
}
// endregion UsuarioField

// region UsuarioFilterBuilder
class UsuarioFilterBuilder extends ConjunctionBase {
  UsuarioFilterBuilder(Usuario obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnUsuario = obj._mnUsuario;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  UsuarioManager? _mnUsuario;

  /// put the sql keyword 'AND'
  @override
  UsuarioFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  UsuarioFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  UsuarioFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  UsuarioFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  UsuarioFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  UsuarioFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  UsuarioFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  UsuarioFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  UsuarioFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  UsuarioFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  UsuarioFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  UsuarioField _setField(UsuarioField? field, String colName, DbType dbtype) {
    return UsuarioField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  UsuarioField? _id;
  UsuarioField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  UsuarioField? _id_veiculo;
  UsuarioField get id_veiculo {
    return _id_veiculo = _setField(_id_veiculo, 'id_veiculo', DbType.integer);
  }

  UsuarioField? _id_rede;
  UsuarioField get id_rede {
    return _id_rede = _setField(_id_rede, 'id_rede', DbType.integer);
  }

  UsuarioField? _cpf;
  UsuarioField get cpf {
    return _cpf = _setField(_cpf, 'cpf', DbType.text);
  }

  UsuarioField? _nome;
  UsuarioField get nome {
    return _nome = _setField(_nome, 'nome', DbType.text);
  }

  UsuarioField? _email;
  UsuarioField get email {
    return _email = _setField(_email, 'email', DbType.text);
  }

  UsuarioField? _telefone;
  UsuarioField get telefone {
    return _telefone = _setField(_telefone, 'telefone', DbType.text);
  }

  UsuarioField? _foto;
  UsuarioField get foto {
    return _foto = _setField(_foto, 'foto', DbType.text);
  }

  UsuarioField? _status;
  UsuarioField get status {
    return _status = _setField(_status, 'status', DbType.text);
  }

  /// Deletes List<Usuario> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnUsuario!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnUsuario!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from usuario ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnUsuario!.updateBatch(qparams, values);
  }

  /// This method always returns [Usuario] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Usuario?
  @override
  Future<Usuario?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnUsuario!.toList(qparams);
    final data = await objFuture;
    Usuario? obj;
    if (data.isNotEmpty) {
      obj = Usuario.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plVeiculo'))) {
          obj.plVeiculo =
              obj.plVeiculo ?? await obj.getVeiculo(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plRede'))) {
          obj.plRede =
              obj.plRede ?? await obj.getRede(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Usuario]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Usuario?
  @override
  Future<Usuario> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Usuario();
  }

  /// This method returns int. [Usuario]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? usuarioCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final usuariosFuture = await _mnUsuario!.toList(qparams);
    final int count = usuariosFuture[0]['CNT'] as int;
    if (usuarioCount != null) {
      usuarioCount(count);
    }
    return count;
  }

  /// This method returns List<Usuario> [Usuario]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Usuario>
  @override
  Future<List<Usuario>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Usuario> usuariosData = await Usuario.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return usuariosData;
  }

  /// This method returns Json String [Usuario]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Usuario]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Usuario]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnUsuario!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Usuario]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM usuario WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnUsuario!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Usuario]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnUsuario!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Usuario.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnUsuario!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion UsuarioFilterBuilder

// region UsuarioFields
class UsuarioFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fId_veiculo;
  static TableField get id_veiculo {
    return _fId_veiculo = _fId_veiculo ??
        SqlSyntax.setField(_fId_veiculo, 'id_veiculo', DbType.integer);
  }

  static TableField? _fId_rede;
  static TableField get id_rede {
    return _fId_rede =
        _fId_rede ?? SqlSyntax.setField(_fId_rede, 'id_rede', DbType.integer);
  }

  static TableField? _fCpf;
  static TableField get cpf {
    return _fCpf = _fCpf ?? SqlSyntax.setField(_fCpf, 'cpf', DbType.text);
  }

  static TableField? _fNome;
  static TableField get nome {
    return _fNome = _fNome ?? SqlSyntax.setField(_fNome, 'nome', DbType.text);
  }

  static TableField? _fEmail;
  static TableField get email {
    return _fEmail =
        _fEmail ?? SqlSyntax.setField(_fEmail, 'email', DbType.text);
  }

  static TableField? _fTelefone;
  static TableField get telefone {
    return _fTelefone =
        _fTelefone ?? SqlSyntax.setField(_fTelefone, 'telefone', DbType.text);
  }

  static TableField? _fFoto;
  static TableField get foto {
    return _fFoto = _fFoto ?? SqlSyntax.setField(_fFoto, 'foto', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'status', DbType.text);
  }
}
// endregion UsuarioFields

//region UsuarioManager
class UsuarioManager extends SqfEntityProvider {
  UsuarioManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'usuario';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion UsuarioManager
// region Rede
class Rede extends TableBase {
  Rede({this.id, this.descricao}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Rede.withFields(this.descricao) {
    _setDefaultValues();
  }
  Rede.withId(this.id, this.descricao) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Rede.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['descricao'] != null) {
      descricao = o['descricao'].toString();
    }
  }
  // FIELDS (Rede)
  int? id;
  String? descricao;

  // end FIELDS (Rede)

// COLLECTIONS & VIRTUALS (Rede)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plUsuarios', 'plField2'..]) or so on..
  List<Usuario>? plUsuarios;

  /// get Usuario(s) filtered by id=id_rede
  UsuarioFilterBuilder? getUsuarios(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Usuario()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .id_rede
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Rede)

  static const bool _softDeleteActivated = false;
  RedeManager? __mnRede;

  RedeManager get _mnRede {
    return __mnRede = __mnRede ?? RedeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (descricao != null || !forView) {
      map['descricao'] = descricao;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (descricao != null || !forView) {
      map['descricao'] = descricao;
    }

// COLLECTIONS (Rede)
    if (!forQuery) {
      map['Usuarios'] = await getUsuarios()!.toMapList();
    }
// END COLLECTIONS (Rede)

    return map;
  }

  /// This method returns Json String [Rede]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Rede]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [descricao];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, descricao];
  }

  static Future<List<Rede>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Rede.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Rede>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Rede>[];
    try {
      objList = list
          .map((rede) => Rede.fromMap(rede as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Rede.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Rede>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Rede> objList = <Rede>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Rede.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('redes.plUsuarios') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUsuarios'))) {
          /*_loadedfields!.add('redes.plUsuarios'); */ obj.plUsuarios =
              obj.plUsuarios ??
                  await obj.getUsuarios()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Rede by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Rede] if exist, otherwise returns null
  Future<Rede?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Rede? obj;
    final data = await _mnRede.getById([id]);
    if (data.length != 0) {
      obj = Rede.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('redes.plUsuarios') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUsuarios'))) {
          /*_loadedfields!.add('redes.plUsuarios'); */ obj.plUsuarios =
              obj.plUsuarios ??
                  await obj.getUsuarios()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Rede) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnRede.insert(this, ignoreBatch);
    } else {
      await _mnRede.update(this);
    }

    return id;
  }

  /// Saves the (Rede) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnRede.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnRede.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Rede. Returns a new Primary Key value of Rede

  /// <returns>Returns a new Primary Key value of Rede
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Rede> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Rede> redes,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in redes) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < redes.length; i++) {
        if (redes[i].id == null) {
          redes[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnRede.rawInsert(
          'INSERT OR REPLACE INTO redes (id, descricao)  VALUES (?,?)',
          [id, descricao],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Rede id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Rede id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Rede Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Rede>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Rede> redes,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnRede.rawInsertAll(
        'INSERT OR REPLACE INTO redes (id, descricao)  VALUES (?,?)', redes,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Rede

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Rede invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result =
          await Usuario().select().id_rede.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnRede
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnRede.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Rede] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  RedeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RedeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  RedeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RedeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion rede

// region RedeField
class RedeField extends FilterBase {
  RedeField(RedeFilterBuilder redeFB) : super(redeFB);

  @override
  RedeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as RedeFilterBuilder;
  }

  @override
  RedeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as RedeFilterBuilder;
  }

  @override
  RedeFilterBuilder isNull() {
    return super.isNull() as RedeFilterBuilder;
  }

  @override
  RedeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as RedeFilterBuilder;
  }

  @override
  RedeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as RedeFilterBuilder;
  }

  @override
  RedeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as RedeFilterBuilder;
  }

  @override
  RedeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as RedeFilterBuilder;
  }

  @override
  RedeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as RedeFilterBuilder;
  }

  @override
  RedeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as RedeFilterBuilder;
  }

  @override
  RedeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as RedeFilterBuilder;
  }

  @override
  RedeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as RedeFilterBuilder;
  }

  @override
  RedeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as RedeFilterBuilder;
  }

  @override
  RedeField get not {
    return super.not as RedeField;
  }
}
// endregion RedeField

// region RedeFilterBuilder
class RedeFilterBuilder extends ConjunctionBase {
  RedeFilterBuilder(Rede obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnRede = obj._mnRede;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  RedeManager? _mnRede;

  /// put the sql keyword 'AND'
  @override
  RedeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  RedeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  RedeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  RedeFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  RedeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  RedeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  RedeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RedeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RedeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RedeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RedeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  RedeField _setField(RedeField? field, String colName, DbType dbtype) {
    return RedeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  RedeField? _id;
  RedeField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  RedeField? _descricao;
  RedeField get descricao {
    return _descricao = _setField(_descricao, 'descricao', DbType.text);
  }

  /// Deletes List<Rede> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (Usuario) according to DeleteRule.CASCADE
    final idListUsuarioBYid_rede = toListPrimaryKeySQL(false);
    final resUsuarioBYid_rede = await Usuario()
        .select()
        .where('id_rede IN (${idListUsuarioBYid_rede['sql']})',
            parameterValue: idListUsuarioBYid_rede['args'])
        .delete(hardDelete);
    if (!resUsuarioBYid_rede.success) {
      return resUsuarioBYid_rede;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnRede!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnRede!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from redes ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnRede!.updateBatch(qparams, values);
  }

  /// This method always returns [Rede] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Rede?
  @override
  Future<Rede?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnRede!.toList(qparams);
    final data = await objFuture;
    Rede? obj;
    if (data.isNotEmpty) {
      obj = Rede.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('redes.plUsuarios') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUsuarios'))) {
          /*_loadedfields!.add('redes.plUsuarios'); */ obj.plUsuarios =
              obj.plUsuarios ??
                  await obj.getUsuarios()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Rede]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Rede?
  @override
  Future<Rede> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Rede();
  }

  /// This method returns int. [Rede]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? redeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final redesFuture = await _mnRede!.toList(qparams);
    final int count = redesFuture[0]['CNT'] as int;
    if (redeCount != null) {
      redeCount(count);
    }
    return count;
  }

  /// This method returns List<Rede> [Rede]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Rede>
  @override
  Future<List<Rede>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Rede> redesData = await Rede.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return redesData;
  }

  /// This method returns Json String [Rede]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Rede]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Rede]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnRede!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Rede]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM redes WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnRede!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Rede]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnRede!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Rede.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnRede!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion RedeFilterBuilder

// region RedeFields
class RedeFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fDescricao;
  static TableField get descricao {
    return _fDescricao = _fDescricao ??
        SqlSyntax.setField(_fDescricao, 'descricao', DbType.text);
  }
}
// endregion RedeFields

//region RedeManager
class RedeManager extends SqfEntityProvider {
  RedeManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'redes';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion RedeManager
// region Veiculo
class Veiculo extends TableBase {
  Veiculo({this.id, this.tipoVeiculo, this.placa}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Veiculo.withFields(this.tipoVeiculo, this.placa) {
    _setDefaultValues();
  }
  Veiculo.withId(this.id, this.tipoVeiculo, this.placa) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Veiculo.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['tipoVeiculo'] != null) {
      tipoVeiculo = o['tipoVeiculo'].toString();
    }
    if (o['placa'] != null) {
      placa = o['placa'].toString();
    }
  }
  // FIELDS (Veiculo)
  int? id;
  String? tipoVeiculo;
  String? placa;

  // end FIELDS (Veiculo)

// COLLECTIONS & VIRTUALS (Veiculo)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plUsuarios', 'plField2'..]) or so on..
  List<Usuario>? plUsuarios;

  /// get Usuario(s) filtered by id=id_veiculo
  UsuarioFilterBuilder? getUsuarios(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Usuario()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .id_veiculo
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Veiculo)

  static const bool _softDeleteActivated = false;
  VeiculoManager? __mnVeiculo;

  VeiculoManager get _mnVeiculo {
    return __mnVeiculo = __mnVeiculo ?? VeiculoManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (tipoVeiculo != null || !forView) {
      map['tipoVeiculo'] = tipoVeiculo;
    }
    if (placa != null || !forView) {
      map['placa'] = placa;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (tipoVeiculo != null || !forView) {
      map['tipoVeiculo'] = tipoVeiculo;
    }
    if (placa != null || !forView) {
      map['placa'] = placa;
    }

// COLLECTIONS (Veiculo)
    if (!forQuery) {
      map['Usuarios'] = await getUsuarios()!.toMapList();
    }
// END COLLECTIONS (Veiculo)

    return map;
  }

  /// This method returns Json String [Veiculo]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Veiculo]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [tipoVeiculo, placa];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, tipoVeiculo, placa];
  }

  static Future<List<Veiculo>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Veiculo.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Veiculo>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Veiculo>[];
    try {
      objList = list
          .map((veiculo) => Veiculo.fromMap(veiculo as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Veiculo.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Veiculo>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Veiculo> objList = <Veiculo>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Veiculo.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('veiculos.plUsuarios') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUsuarios'))) {
          /*_loadedfields!.add('veiculos.plUsuarios'); */ obj.plUsuarios =
              obj.plUsuarios ??
                  await obj.getUsuarios()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Veiculo by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Veiculo] if exist, otherwise returns null
  Future<Veiculo?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Veiculo? obj;
    final data = await _mnVeiculo.getById([id]);
    if (data.length != 0) {
      obj = Veiculo.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('veiculos.plUsuarios') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUsuarios'))) {
          /*_loadedfields!.add('veiculos.plUsuarios'); */ obj.plUsuarios =
              obj.plUsuarios ??
                  await obj.getUsuarios()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Veiculo) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnVeiculo.insert(this, ignoreBatch);
    } else {
      await _mnVeiculo.update(this);
    }

    return id;
  }

  /// Saves the (Veiculo) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnVeiculo.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnVeiculo.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Veiculo. Returns a new Primary Key value of Veiculo

  /// <returns>Returns a new Primary Key value of Veiculo
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Veiculo> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Veiculo> veiculos,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in veiculos) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < veiculos.length; i++) {
        if (veiculos[i].id == null) {
          veiculos[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnVeiculo.rawInsert(
          'INSERT OR REPLACE INTO veiculos (id, tipoVeiculo, placa)  VALUES (?,?,?)',
          [id, tipoVeiculo, placa],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Veiculo id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Veiculo id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Veiculo Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Veiculo>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Veiculo> veiculos,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnVeiculo.rawInsertAll(
        'INSERT OR REPLACE INTO veiculos (id, tipoVeiculo, placa)  VALUES (?,?,?)',
        veiculos,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Veiculo

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Veiculo invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result =
          await Usuario().select().id_veiculo.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnVeiculo
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnVeiculo.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Veiculo] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  VeiculoFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VeiculoFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  VeiculoFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VeiculoFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion veiculo

// region VeiculoField
class VeiculoField extends FilterBase {
  VeiculoField(VeiculoFilterBuilder veiculoFB) : super(veiculoFB);

  @override
  VeiculoFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as VeiculoFilterBuilder;
  }

  @override
  VeiculoFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as VeiculoFilterBuilder;
  }

  @override
  VeiculoFilterBuilder isNull() {
    return super.isNull() as VeiculoFilterBuilder;
  }

  @override
  VeiculoFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as VeiculoFilterBuilder;
  }

  @override
  VeiculoFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as VeiculoFilterBuilder;
  }

  @override
  VeiculoFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as VeiculoFilterBuilder;
  }

  @override
  VeiculoFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as VeiculoFilterBuilder;
  }

  @override
  VeiculoFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as VeiculoFilterBuilder;
  }

  @override
  VeiculoFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as VeiculoFilterBuilder;
  }

  @override
  VeiculoFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as VeiculoFilterBuilder;
  }

  @override
  VeiculoFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as VeiculoFilterBuilder;
  }

  @override
  VeiculoFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as VeiculoFilterBuilder;
  }

  @override
  VeiculoField get not {
    return super.not as VeiculoField;
  }
}
// endregion VeiculoField

// region VeiculoFilterBuilder
class VeiculoFilterBuilder extends ConjunctionBase {
  VeiculoFilterBuilder(Veiculo obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnVeiculo = obj._mnVeiculo;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  VeiculoManager? _mnVeiculo;

  /// put the sql keyword 'AND'
  @override
  VeiculoFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  VeiculoFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  VeiculoFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  VeiculoFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  VeiculoFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  VeiculoFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  VeiculoFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  VeiculoFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  VeiculoFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  VeiculoFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  VeiculoFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  VeiculoField _setField(VeiculoField? field, String colName, DbType dbtype) {
    return VeiculoField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  VeiculoField? _id;
  VeiculoField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  VeiculoField? _tipoVeiculo;
  VeiculoField get tipoVeiculo {
    return _tipoVeiculo = _setField(_tipoVeiculo, 'tipoVeiculo', DbType.text);
  }

  VeiculoField? _placa;
  VeiculoField get placa {
    return _placa = _setField(_placa, 'placa', DbType.text);
  }

  /// Deletes List<Veiculo> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (Usuario) according to DeleteRule.CASCADE
    final idListUsuarioBYid_veiculo = toListPrimaryKeySQL(false);
    final resUsuarioBYid_veiculo = await Usuario()
        .select()
        .where('id_veiculo IN (${idListUsuarioBYid_veiculo['sql']})',
            parameterValue: idListUsuarioBYid_veiculo['args'])
        .delete(hardDelete);
    if (!resUsuarioBYid_veiculo.success) {
      return resUsuarioBYid_veiculo;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnVeiculo!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnVeiculo!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from veiculos ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnVeiculo!.updateBatch(qparams, values);
  }

  /// This method always returns [Veiculo] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Veiculo?
  @override
  Future<Veiculo?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnVeiculo!.toList(qparams);
    final data = await objFuture;
    Veiculo? obj;
    if (data.isNotEmpty) {
      obj = Veiculo.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('veiculos.plUsuarios') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUsuarios'))) {
          /*_loadedfields!.add('veiculos.plUsuarios'); */ obj.plUsuarios =
              obj.plUsuarios ??
                  await obj.getUsuarios()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Veiculo]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Veiculo?
  @override
  Future<Veiculo> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Veiculo();
  }

  /// This method returns int. [Veiculo]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? veiculoCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final veiculosFuture = await _mnVeiculo!.toList(qparams);
    final int count = veiculosFuture[0]['CNT'] as int;
    if (veiculoCount != null) {
      veiculoCount(count);
    }
    return count;
  }

  /// This method returns List<Veiculo> [Veiculo]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Veiculo>
  @override
  Future<List<Veiculo>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Veiculo> veiculosData = await Veiculo.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return veiculosData;
  }

  /// This method returns Json String [Veiculo]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Veiculo]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Veiculo]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnVeiculo!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Veiculo]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM veiculos WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnVeiculo!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Veiculo]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnVeiculo!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Veiculo.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnVeiculo!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion VeiculoFilterBuilder

// region VeiculoFields
class VeiculoFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fTipoVeiculo;
  static TableField get tipoVeiculo {
    return _fTipoVeiculo = _fTipoVeiculo ??
        SqlSyntax.setField(_fTipoVeiculo, 'tipoVeiculo', DbType.text);
  }

  static TableField? _fPlaca;
  static TableField get placa {
    return _fPlaca =
        _fPlaca ?? SqlSyntax.setField(_fPlaca, 'placa', DbType.text);
  }
}
// endregion VeiculoFields

//region VeiculoManager
class VeiculoManager extends SqfEntityProvider {
  VeiculoManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'veiculos';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion VeiculoManager
class MyDbModelSequenceManager extends SqfEntityProvider {
  MyDbModelSequenceManager() : super(MyDbModel());
}
// END OF ENTITIES
